#!/bin/bash
# Synchronise subtrees between remote hosts using rsync.

# development directories, override on install
SCRIPT_HOME="$(dirname "$(readlink -f "$0")")"
DATADIR="$SCRIPT_HOME/share"

set -e -o pipefail # POSIX:2022

abort() { echo >&2 "$2"; exit $1; }

DRYRUN=false
CONFIRM=true
rrsync() {
	local run="$1"
	local dir_src="$2"
	local dir_dst="$3"
	local subdir="$4"
	shift 4

	dir_src="${dir_src%/}/"
	dir_dst="${dir_dst%/}/"
	# setup rsync includes/excludes to only include our specific subdir
	local inexcl=()
	local inexclq=
	while [[ "$subdir" != "." ]]; do
		inexcl+=( "--include=/$subdir" )
		inexclq="$inexclq %q"
		subdir="$(dirname "$subdir")"
		if [[ "$subdir" != "." ]]; then
			inexcl+=( "--exclude=/$subdir/*" )
		else
			inexcl+=( "--exclude=/*" )
		fi
		inexclq="$inexclq %q"
	done

	if $DRYRUN; then
		printf "${PS4}cat <<'eof' | rsync -n --exclude-from=-${inexclq} $* %q %q\n" "${inexcl[@]}" "$dir_src" "$dir_dst"
		xtsync_excludes
		printf "eof\n"
		return
	fi

	if $CONFIRM; then
		"$run" rsync -n \
		  --exclude-from=<(xtsync_excludes) "${inexcl[@]}" \
		  "$@" "$dir_src" "$dir_dst" 2>&1 | less
		read -p "Execute this run? [y/N] " x
		test "$x" = "y" || return 1
	fi
	"$run" rsync \
	  --exclude-from=<(xtsync_excludes) "${inexcl[@]}" \
	  "$@" "$dir_src" "$dir_dst"
}

if [[ "${RSYNC_NO_DELETE}" = 1 ]]; then
	RSYNC_FLAGS="-acvxz --no-g --no-o ${RSYNC_FLAGS}"
else
	RSYNC_FLAGS="-acvxz --no-g --no-o --delete ${RSYNC_FLAGS}"
fi
runsync() {(
	local direc="$1"
	local dir_l="$2"
	local dir_r="$3"
	local subdir="$4"
	cd "$dir_l" # to run hooks

	# we pass -u explicitly here outside of RSYNC_FLAGS because we need to
	# exclude it from the rsync invocation in rundiff for that to work
	case "$direc" in
	u|up)
		xtsync_pre_u || abort 1 "$0: xtsync_pre_u failed"
		rrsync xtsync_wrap_u "$dir_l" "$dir_r" "$subdir" -u $RSYNC_FLAGS
		xtsync_post_u || abort 1 "$0: xtsync_post_u failed"
		;;
	d|down)
		xtsync_pre_d || abort 1 "$0: xtsync_pre_d failed"
		rrsync xtsync_wrap_d "$dir_r" "$dir_l" "$subdir" -u $RSYNC_FLAGS
		xtsync_post_d || abort 1 "$0: xtsync_post_d failed"
		;;
	esac
)}

type colordiff >/dev/null 2>&1 && DIFF=colordiff || {
	echo >&2 "colordiff(1) not found; using diff(1) instead"
	DIFF=diff
}
rundiff() {(
	local direc="$1"
	local dir_l="$2"
	local dir_r="$3"
	local subdir="$4"

	tempdir="$(mktemp -d)"
	cleanup () {
		rm -rf "$tempdir"
	}
	trap 'x=$?; cleanup; trap - EXIT' EXIT HUP INT QUIT PIPE TERM
	# apply excludes to local copy
	DRYRUN=false CONFIRM=false rrsync env "$dir_l"     "$tempdir/l" "$subdir" -q $RSYNC_FLAGS
	# sync using local copy first, to save some bandwidth
	DRYRUN=false CONFIRM=false rrsync env "$tempdir/l" "$tempdir/r" "$subdir" -q $RSYNC_FLAGS
	DRYRUN=false CONFIRM=false rrsync env "$dir_r"     "$tempdir/r" "$subdir" -q $RSYNC_FLAGS
	case "$direc" in
	u|up)
		$DIFF -Nru "$tempdir/r" "$tempdir/l" | less -R
		;;
	d|down)
		$DIFF -Nru "$tempdir/l" "$tempdir/r" | less -R
		;;
	esac
)}

findconfig() {
	if [ -f "$1" ]; then
		printf '%s\n' "${PWD%/}"
		if [ -z "$2" ]; then
			return
		fi
	fi
	if [ "$PWD" = / ]; then
		false
	else
		# a subshell so that we don't affect the caller's $PWD
		(cd .. && findconfig "$1")
	fi
}

tab_lookup() {
	local key="$1"
	shift
	tac "$@" | {
	while read x y; do
		if [[ "$x" = "$key" ]]; then
			printf "%s\n" "${y%/}" # strip trailing /
			break
		fi
	done
	}
}

abspath() { cd "$1"; pwd; cd "$OLDPWD"; }

. "$DATADIR/xtsync.rc.default" # load defaults
run() {(
	local cmd="$1"
	local direc="$2"
	local dir="$(realpath "$3")" # realpath = same behaviour as git in finding .git

	# we must set the transfer-root to the same directory where .xtsync.rc is
	# so that rsync interprets the exclude rules correctly. to select the right
	# subdir within this, we pass various include/exclude args in rrsync above
	local dir_l="$(cd "$dir"; findconfig .xtsync.rc || true)"
	if [ -f "$dir_l/.xtsync.rc" ]; then
		. "$dir_l/.xtsync.rc"
	fi

	local tabs
	mapfile -t tabs < <(cd "$dir"; findconfig .xtsync.tab 1 | sed 's,$,/.xtsync.tab,g')

	if [[ "${#tabs[@]}" = 0 ]]; then
		echo >&2 "no .xtsync.tab found; it is recommended you create one in ~ or wherever the local base is"
	fi

	local host_l="$(hostname)"
	local host_r="${REMOTE:-$(tab_lookup .default.remote "${tabs[@]}")}"
	test -n "$host_r" || { echo >&2 "could not determine remote host for dir: $dir"; return 1; }
	local base_l="$(python -c 'import sys, os; print(os.path.expanduser(sys.argv[1]))' "$(tab_lookup "$host_l" "${tabs[@]}")")"
	local base_r="$host_r:$(tab_lookup "$host_r" "${tabs[@]}")"

	if [[ -n "$DEBUG" ]]; then
		echo >&2 "cmd    $cmd"
		echo >&2 "direc  $direc"
		echo >&2 "base_l $base_l"
		echo >&2 "base_r $base_r"
	fi

	if [[ -z "$dir_l" ]]; then
		dir_l="$dir"
	fi

	if [[ "${dir_l}"/. != "${base_l}"/* ]]; then
		echo >&2 "not under local base $base_l: dir_l $dir_l"
		return 1
	fi

	local subdir="$(realpath --relative-to="$dir_l" "$dir")"
	local dir_r="$base_r${dir_l#$base_l}" # appends either "" or "/something" to base_r

	if [[ -n "$DEBUG" ]]; then
		echo >&2 "dir_l  $dir_l"
		echo >&2 "dir    $dir"
		echo >&2 "subdir $subdir"
		echo >&2 "dir_r  $dir_r"
	fi

	$cmd "$direc" "$dir_l" "$dir_r" "$subdir"
)}

RUNCMD=runsync
USAGE="Usage: $0 -r <REMOTE> [OPTIONS] <DIRECTION> <DIR> [<DIR> ...]"
while getopts r:dnyh o; do
	case $o in
	r ) REMOTE="$OPTARG";;
	d ) RUNCMD=rundiff;;
	n ) DRYRUN=true;;
	y ) CONFIRM=false;;
	h )
		cat <<-EOF
		$USAGE

		Synchronise subtrees between remote hosts using rsync.

		This should be largely compatible with unison(1) when using the same BASE
		directories (called "roots" in unison), but is a bit easier to automate.

		This command runs several instances of ssh(1). It is recommended that you
		use a remote Host where you've configured a ControlPath; see ssh_config(5)
		for details. Before running this script, run \`ssh -M \$host\` to set up the
		master connection, and this script will then run through that. (This tip is
		useful for unison too.)

		Arguments:
		DIRECTION           Up = sync local to remote; Down = sync remote to local.
		DIR                 Directory to sync. If \$DIR = \$LOCAL/\$RELATIVE,
		                    then \$DIR will be synced to/from \$REMOTE/\$RELATIVE.

		Options:
		  -r REMOTE         Remote host name, in the form accepted by ssh(1).
		  -n                Print the command to be run, rather than running it.
		  -d                Print a diff of what rsync would apply. Practically,
		                    this syncs to a temporary directory then runs diff(1) on
		                    it. This is slower but prettier than unison(1).
		  -y                Skip confirmation request.
		  -h                This help text.
		EOF
		exit 1
		;;
	\? ) echo $USAGE; exit 1;;
	esac
done
shift `expr $OPTIND - 1`

DIREC="$1"

case "$DIREC" in
u|up);;
d|down);;
*)
	abort 2 "specify a direction, up or down."
	;;
esac
shift

test -n "$*" || abort 2 "no paths selected"

x=0
for D in "$@"; do
	run "$RUNCMD" "$DIREC" "$D" || y=$?
	x=$(( x > y ? x : y ))
done
exit "$x"
